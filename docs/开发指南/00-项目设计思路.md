# 项目设计思路

> 本文档介绍 coc_robot 的核心架构设计思路，帮助开发者快速理解项目结构。

## 🎯 设计理念

**分层架构 + 任务流模式**

项目采用三层架构设计，从底层到上层依次为：
1. **底层接口层** - 封装基础能力（识图、OCR、YOLO等）
2. **机器人层** - 管理任务执行流程
3. **监控层** - 多机器人管理和异常恢复

## 📦 第一层：底层接口封装

### 设计原则

✅ **单一职责**：每个接口类只做一件事
✅ **线程安全**：支持多线程并发调用
✅ **可单元测试**：接口独立，易于测试

### 核心接口

#### 1. 图像识别接口

**模板匹配引擎**

```python
# 模块/检测/模板匹配器.py
class 模板匹配引擎:
    """OpenCV模板匹配，线程安全"""

    def 执行匹配(self, 图像, 模板路径, 相似度阈值):
        """
        参数：
            图像 - 待匹配的屏幕图像
            模板路径 - 模板文件路径（支持多模板：'a.bmp|b.bmp'）
            相似度阈值 - 0-1之间的浮点数

        返回：
            (是否匹配, (x, y), 相似度)
        """
        pass
```

**YOLO检测器**

```python
# 模块/检测/YOLO检测器.py
class 线程安全YOLO检测器:
    """YOLO v5目标检测，线程安全"""

    def 检测(self, 图像):
        """
        参数：
            图像 - 待检测的图像

        返回：
            检测结果列表: [
                {
                    "类别名称": "gold_storage",
                    "裁剪坐标": (x1, y1, x2, y2),
                    "置信度": 0.95
                },
                ...
            ]
        """
        pass
```

**OCR识别器**

```python
# 模块/检测/OCR识别器.py
class 安全OCR引擎:
    """PaddleOCR文字识别，线程安全"""

    def __call__(self, 图像):
        """
        参数：
            图像 - 待识别的图像

        返回：
            (识别结果, 耗时)
            识别结果格式: [
                [[[x1, y1], [x2, y2], [x3, y3], [x4, y4]], "文本内容"],
                ...
            ]
        """
        pass
```

#### 2. 模拟器控制接口

```python
# 模块/雷电模拟器操作类.py
class 雷电模拟器操作类:
    """雷电模拟器API封装"""

    def 启动(self) -> bool:
        """启动模拟器"""
        pass

    def 关闭(self) -> bool:
        """关闭模拟器"""
        pass

    def 启动包(self, 包名: str) -> bool:
        """启动指定应用"""
        pass

    def 检查模拟器是否运行(self) -> bool:
        """检测模拟器是否在运行"""
        pass
```

#### 3. 输入控制接口

```python
# 核心/鼠标操作.py
class 鼠标控制器:
    def 移动(self, x, y): pass
    def 点击(self): pass
    def 拖动(self, x1, y1, x2, y2): pass

# 核心/键盘操作.py
class 键盘控制器:
    def 按下(self, 键名): pass
    def 释放(self, 键名): pass
```

### 为什么这样设计？

✅ **解耦合**：识图逻辑与任务逻辑分离
✅ **可复用**：多个任务共享同一套检测引擎
✅ **易测试**：可以独立测试每个接口
✅ **线程安全**：支持多机器人并发运行

## 🤖 第二层：自动化机器人类

### 设计原则

✅ **状态管理**：清晰的状态转换（运行、暂停、停止）
✅ **异常恢复**：自动捕获异常并重启
✅ **上下文传递**：统一的资源访问方式

### 机器人接口

```python
# 线程/自动化机器人.py
class 自动化机器人:
    """机器人线程类，负责执行任务流程"""

    def __init__(self, 机器人标志: str, 设置: 机器人设置):
        self.机器人标志 = 机器人标志
        self.设置 = 设置
        self.线程 = None
        self.状态 = "未启动"

    # === 核心接口 ===

    def 开始(self):
        """启动机器人线程"""
        self.线程 = threading.Thread(target=self._任务流程)
        self.线程.start()

    def 停止(self):
        """停止机器人（优雅退出）"""
        self.停止事件.set()

    def 暂停(self):
        """暂停执行"""
        self.继续事件.clear()

    def 继续(self):
        """恢复执行"""
        self.继续事件.set()

    def 获取状态(self) -> dict:
        """获取机器人当前状态"""
        return {
            "状态": self.状态,
            "最后日志": self._最后日志,
            "运行时间": self._运行时间
        }

    def 更新设置(self, 新设置: 机器人设置):
        """动态更新配置"""
        self.设置 = 新设置

    # === 内部方法 ===

    def _任务流程(self):
        """任务执行的主循环"""
        while not self.停止事件.is_set():
            try:
                # 创建任务上下文
                上下文 = self._创建任务上下文()

                # 执行任务链
                self._执行任务链(上下文)

            except Exception as e:
                # 异常处理和重启逻辑
                self._处理异常(e)
```

### 任务上下文（Context）

**核心思想**：将所有资源打包传递给任务

```python
# 任务流程/基础任务框架.py
@dataclass
class 任务上下文:
    """任务执行所需的所有资源"""

    # 基本信息
    机器人标志: str
    数据库: 任务数据库

    # 线程控制
    消息队列: queue.Queue
    继续事件: threading.Event
    停止事件: threading.Event

    # 底层接口
    op: op类                      # 屏幕截图
    雷电模拟器: 雷电模拟器操作类
    键盘: 键盘控制器
    鼠标: 鼠标控制器

    # 工具方法
    置脚本状态: Callable          # 日志记录

    # === 便捷方法 ===

    def 点击(self, x, y, 延时=500, 是否精确点击=False):
        """智能点击（自动加随机偏移）"""
        if not 是否精确点击:
            x += random.randint(-5, 5)
            y += random.randint(-5, 5)
        self.鼠标.移动(x, y)
        self.鼠标.点击()
        self.脚本延时(延时)

    def 脚本延时(self, 毫秒):
        """线程安全的延时（支持暂停/停止）"""
        步进 = 100
        for _ in range(毫秒 // 步进):
            if self.停止事件.is_set():
                return
            self.继续事件.wait()  # 暂停时阻塞
            time.sleep(步进 / 1000)
```

### 任务基类设计

**核心思想**：统一的任务接口，自动初始化检测引擎

```python
# 任务流程/基础任务框架.py
class 基础任务(ABC):
    """所有任务的基类"""

    def __init__(self, 上下文: 任务上下文):
        self.上下文 = 上下文

        # 自动初始化检测引擎（避免每个任务重复初始化）
        self.模板识别 = 模板匹配引擎()
        self.ocr引擎 = 安全OCR引擎()
        self.检测器 = 线程安全YOLO检测器()

        # 便捷属性
        self.数据库 = 上下文.数据库
        self.机器人标志 = 上下文.机器人标志

    @abstractmethod
    def 执行(self) -> bool:
        """
        任务执行逻辑

        返回值：
            True - 任务成功，继续下一任务
            False - 任务失败，终止流程
        """
        pass

    def 异常处理(self, 异常, 是否重启游戏=True, 是否重启机器人=True):
        """统一的异常处理"""
        self.上下文.处理异常(
            self.__class__.__name__,
            异常,
            是否重启游戏,
            是否重启机器人
        )
```

### 任务开发示例

```python
from 任务流程.基础任务框架 import 基础任务

class 我的新任务(基础任务):
    """任务说明"""

    def 执行(self) -> bool:
        try:
            上下文 = self.上下文
            上下文.置脚本状态("开始执行我的任务")

            # 1. 截图
            屏幕图像 = 上下文.op.获取屏幕图像cv(0, 0, 800, 600)

            # 2. 检测（使用预初始化的引擎）
            是否匹配, (x, y), _ = self.模板识别.执行匹配(
                屏幕图像,
                "按钮.bmp",
                0.9
            )

            # 3. 操作
            if 是否匹配:
                上下文.点击(x, y, 500)

            return True  # 任务成功

        except Exception as e:
            self.异常处理(e)
            return False  # 任务失败
```

### 为什么这样设计？

✅ **统一接口**：所有任务遵循相同的模式
✅ **上下文传递**：避免全局变量，资源集中管理
✅ **自动初始化**：检测引擎只初始化一次，提高性能
✅ **清晰职责**：机器人负责调度，任务负责执行

## 🎛️ 第三层：监控中心类

### 设计原则

✅ **集中管理**：统一管理所有机器人
✅ **健康检查**：定期检测机器人状态
✅ **自动恢复**：卡死自动重启

### 监控中心接口

```python
# 监控中心.py
class 机器人监控中心:
    """管理和监控多个机器人"""

    def __init__(self, 数据库: 任务数据库):
        self.数据库 = 数据库
        self.机器人池: Dict[str, 自动化机器人] = {}
        self._监控线程 = None

    # === 机器人管理 ===

    def 创建机器人(self, 机器人标志: str, 初始设置: 机器人设置):
        """创建新机器人"""
        机器人 = 自动化机器人(机器人标志, 初始设置)
        self.机器人池[机器人标志] = 机器人

    def 启动机器人(self, 机器人标志: str):
        """启动指定机器人"""
        if 机器人 := self.机器人池.get(机器人标志):
            机器人.开始()

    def 停止机器人(self, 机器人标志: str):
        """停止指定机器人"""
        if 机器人 := self.机器人池.get(机器人标志):
            机器人.停止()

    def 删除机器人(self, 机器人标志: str):
        """删除机器人（先停止再删除）"""
        if 机器人 := self.机器人池.get(机器人标志):
            机器人.停止()
            del self.机器人池[机器人标志]

    # === 状态监控 ===

    def 启动监控(self):
        """启动监控线程"""
        self._监控线程 = threading.Thread(target=self._监控循环)
        self._监控线程.daemon = True
        self._监控线程.start()

    def _监控循环(self):
        """监控主循环"""
        while True:
            time.sleep(10)  # 每10秒检查一次

            for 机器人标志, 机器人 in self.机器人池.items():
                try:
                    # 检查机器人是否卡死
                    if self._检测卡死(机器人):
                        self._重启机器人(机器人标志)
                except Exception as e:
                    print(f"监控异常: {e}")

    def _检测卡死(self, 机器人: 自动化机器人) -> bool:
        """检测机器人是否卡死"""
        # 检查最后日志时间
        最后日志 = self.数据库.读取最后日志(机器人.机器人标志)
        if 最后日志:
            超时时间 = 最后日志.下次超时
            if time.time() > 超时时间:
                return True  # 超时，判定为卡死
        return False

    def _重启机器人(self, 机器人标志: str):
        """重启卡死的机器人"""
        print(f"检测到机器人 {机器人标志} 卡死，准备重启...")

        # 停止旧机器人
        self.停止机器人(机器人标志)
        time.sleep(2)

        # 重新启动
        self.启动机器人(机器人标志)

    # === 批量操作 ===

    def 启动所有机器人(self):
        """启动所有机器人"""
        for 机器人标志 in self.机器人池.keys():
            self.启动机器人(机器人标志)

    def 停止所有机器人(self):
        """停止所有机器人"""
        for 机器人标志 in self.机器人池.keys():
            self.停止机器人(机器人标志)

    def 获取所有状态(self) -> Dict[str, dict]:
        """获取所有机器人状态"""
        状态字典 = {}
        for 机器人标志, 机器人 in self.机器人池.items():
            状态字典[机器人标志] = 机器人.获取状态()
        return 状态字典
```

### 为什么这样设计？

✅ **统一管理**：一个中心管理多个机器人
✅ **健康监控**：自动检测并恢复卡死的机器人
✅ **批量操作**：方便同时控制多个机器人
✅ **可扩展**：易于添加新的监控策略

## 🔄 数据流向

```
用户操作（GUI/CLI）
    ↓
监控中心
    ↓
机器人1  机器人2  机器人3  ...
    ↓
任务上下文
    ↓
任务1 → 任务2 → 任务3 → ...
    ↓
底层接口（识图/OCR/YOLO/模拟器控制）
```

## 📋 设计优势总结

| 层级 | 优势 |
|------|------|
| **底层接口** | 单一职责、线程安全、可单元测试 |
| **机器人层** | 状态管理、异常恢复、上下文传递 |
| **监控层** | 集中管理、健康检查、自动恢复 |

## 🎓 学习路径

1. **理解底层接口** → 看 `模块/检测/` 目录
2. **理解任务基类** → 看 `任务流程/基础任务框架.py`
3. **学习任务开发** → 看 `开发指南/02-开发第一个任务.md`
4. **理解机器人** → 看 `线程/自动化机器人.py`
5. **理解监控中心** → 看 `监控中心.py`

## 🔗 相关文档

- [快速开始](./01-快速开始.md) - 搭建开发环境
- [开发第一个任务](./02-开发第一个任务.md) - 手把手教学
- [核心架构](../核心文档/核心架构.md) - 详细API文档
