"""
任务依赖管理器

管理任务之间的依赖关系，自动检查执行顺序
"""

from typing import List, Type, Dict, Set
from 任务流程.基础任务框架 import 基础任务
from 任务流程.任务元数据 import 任务元数据


class 任务依赖异常(Exception):
    """任务依赖相关异常"""
    pass


class 循环依赖异常(任务依赖异常):
    """检测到循环依赖"""
    pass


class 缺失依赖异常(任务依赖异常):
    """依赖的任务不存在"""
    pass


class 任务依赖管理器:
    """管理任务依赖关系"""

    def __init__(self, 任务列表: List[Type[基础任务]]):
        """
        初始化依赖管理器

        参数:
            任务列表: 所有可用的任务类列表
        """
        self.任务列表 = 任务列表
        self.任务字典: Dict[str, Type[基础任务]] = {}
        self.依赖图: Dict[str, List[str]] = {}

        self._构建依赖图()

    def _构建依赖图(self):
        """构建任务依赖关系图"""
        # 建立任务名称到任务类的映射
        for 任务类 in self.任务列表:
            if hasattr(任务类, '元数据') and 任务类.元数据:
                任务名 = 任务类.元数据.任务名称
                self.任务字典[任务名] = 任务类
                self.依赖图[任务名] = 任务类.元数据.前置任务 or []

    def 检查循环依赖(self) -> List[List[str]]:
        """
        检测循环依赖

        返回:
            循环依赖链列表，如果没有循环依赖返回空列表
        """
        循环列表 = []

        # 用于DFS的访问标记
        访问状态 = {任务名: "未访问" for 任务名 in self.依赖图.keys()}  # 未访问/访问中/已完成
        当前路径 = []

        def dfs(任务名: str):
            if 访问状态[任务名] == "已完成":
                return

            if 访问状态[任务名] == "访问中":
                # 检测到循环
                循环起始 = 当前路径.index(任务名)
                循环路径 = 当前路径[循环起始:] + [任务名]
                循环列表.append(循环路径)
                return

            访问状态[任务名] = "访问中"
            当前路径.append(任务名)

            # 递归访问依赖
            for 依赖任务 in self.依赖图.get(任务名, []):
                if 依赖任务 in self.依赖图:
                    dfs(依赖任务)

            当前路径.pop()
            访问状态[任务名] = "已完成"

        # 对每个任务执行DFS
        for 任务名 in self.依赖图.keys():
            if 访问状态[任务名] == "未访问":
                dfs(任务名)

        return 循环列表

    def 检查缺失依赖(self) -> Dict[str, List[str]]:
        """
        检查缺失的依赖

        返回:
            {任务名: [缺失的依赖列表]}
        """
        缺失字典 = {}

        for 任务名, 依赖列表 in self.依赖图.items():
            缺失的依赖 = [依赖 for 依赖 in 依赖列表 if 依赖 not in self.任务字典]
            if 缺失的依赖:
                缺失字典[任务名] = 缺失的依赖

        return 缺失字典

    def 拓扑排序(self, 任务名称列表: List[str] = None) -> List[str]:
        """
        对任务进行拓扑排序，返回可执行的顺序

        参数:
            任务名称列表: 要执行的任务列表，如果为None则对所有任务排序

        返回:
            排序后的任务名称列表
        """
        # 检查循环依赖
        循环依赖 = self.检查循环依赖()
        if 循环依赖:
            raise 循环依赖异常(f"检测到循环依赖: {循环依赖}")

        # 检查缺失依赖
        缺失依赖 = self.检查缺失依赖()
        if 缺失依赖:
            raise 缺失依赖异常(f"检测到缺失依赖: {缺失依赖}")

        # 如果未指定任务列表，则使用所有任务
        if 任务名称列表 is None:
            任务名称列表 = list(self.依赖图.keys())

        # 计算需要执行的所有任务（包括依赖）
        需要执行的任务: Set[str] = set()

        def 添加任务及其依赖(任务名: str):
            if 任务名 in 需要执行的任务:
                return
            需要执行的任务.add(任务名)
            for 依赖任务 in self.依赖图.get(任务名, []):
                添加任务及其依赖(依赖任务)

        for 任务名 in 任务名称列表:
            if 任务名 in self.依赖图:
                添加任务及其依赖(任务名)

        # 拓扑排序（Kahn算法）
        入度 = {任务: 0 for 任务 in 需要执行的任务}
        for 任务名 in 需要执行的任务:
            for 依赖任务 in self.依赖图.get(任务名, []):
                if 依赖任务 in 需要执行的任务:
                    入度[任务名] += 1

        # 找到所有入度为0的任务
        队列 = [任务 for 任务, 度 in 入度.items() if 度 == 0]
        结果 = []

        while 队列:
            # 取出一个入度为0的任务
            当前任务 = 队列.pop(0)
            结果.append(当前任务)

            # 更新依赖当前任务的其他任务的入度
            for 任务名 in 需要执行的任务:
                if 当前任务 in self.依赖图.get(任务名, []):
                    入度[任务名] -= 1
                    if 入度[任务名] == 0:
                        队列.append(任务名)

        return 结果

    def 获取任务依赖树(self, 任务名: str, 深度: int = 0) -> str:
        """
        获取任务的依赖树（可视化）

        参数:
            任务名: 任务名称
            深度: 当前递归深度（用于缩进）

        返回:
            依赖树的字符串表示
        """
        缩进 = "  " * 深度
        树 = f"{缩进}{任务名}\n"

        依赖列表 = self.依赖图.get(任务名, [])
        for 依赖任务 in 依赖列表:
            if 依赖任务 in self.依赖图:
                树 += self.获取任务依赖树(依赖任务, 深度 + 1)
            else:
                树 += f"{缩进}  {依赖任务} (缺失)\n"

        return 树

    def 获取依赖该任务的任务列表(self, 任务名: str) -> List[str]:
        """
        获取依赖指定任务的所有任务

        参数:
            任务名: 任务名称

        返回:
            依赖该任务的任务名称列表
        """
        依赖者列表 = []
        for 其他任务, 依赖列表 in self.依赖图.items():
            if 任务名 in 依赖列表:
                依赖者列表.append(其他任务)
        return 依赖者列表


# ===== 测试代码 =====
if __name__ == "__main__":
    from 任务流程.基础任务框架 import 基础任务
    from 任务流程.任务元数据 import 任务元数据

    # 创建测试任务
    class 任务A(基础任务):
        元数据 = 任务元数据(
            任务名称="任务A",
            显示名称="任务A",
            前置任务=[]
        )

        def 执行(self):
            pass

    class 任务B(基础任务):
        元数据 = 任务元数据(
            任务名称="任务B",
            显示名称="任务B",
            前置任务=["任务A"]
        )

        def 执行(self):
            pass

    class 任务C(基础任务):
        元数据 = 任务元数据(
            任务名称="任务C",
            显示名称="任务C",
            前置任务=["任务A", "任务B"]
        )

        def 执行(self):
            pass

    class 任务D(基础任务):
        元数据 = 任务元数据(
            任务名称="任务D",
            显示名称="任务D",
            前置任务=["任务C"]
        )

        def 执行(self):
            pass

    # 创建依赖管理器
    管理器 = 任务依赖管理器([任务A, 任务B, 任务C, 任务D])

    print("=" * 50)
    print("依赖图：")
    for 任务名, 依赖列表 in 管理器.依赖图.items():
        print(f"  {任务名} -> {依赖列表}")

    print("\n" + "=" * 50)
    print("检查循环依赖：")
    循环依赖 = 管理器.检查循环依赖()
    if 循环依赖:
        print(f"  发现循环依赖: {循环依赖}")
    else:
        print("  未发现循环依赖")

    print("\n" + "=" * 50)
    print("检查缺失依赖：")
    缺失依赖 = 管理器.检查缺失依赖()
    if 缺失依赖:
        print(f"  发现缺失依赖: {缺失依赖}")
    else:
        print("  未发现缺失依赖")

    print("\n" + "=" * 50)
    print("拓扑排序结果：")
    try:
        排序结果 = 管理器.拓扑排序()
        print(f"  执行顺序: {' -> '.join(排序结果)}")
    except 任务依赖异常 as e:
        print(f"  排序失败: {e}")

    print("\n" + "=" * 50)
    print("任务D的依赖树：")
    print(管理器.获取任务依赖树("任务D"))

    print("\n" + "=" * 50)
    print("依赖任务A的任务：")
    依赖者 = 管理器.获取依赖该任务的任务列表("任务A")
    print(f"  {依赖者}")

    # 测试循环依赖检测
    print("\n" + "=" * 50)
    print("测试循环依赖：")

    class 任务E(基础任务):
        元数据 = 任务元数据(
            任务名称="任务E",
            显示名称="任务E",
            前置任务=["任务F"]
        )

        def 执行(self):
            pass

    class 任务F(基础任务):
        元数据 = 任务元数据(
            任务名称="任务F",
            显示名称="任务F",
            前置任务=["任务E"]  # 循环依赖
        )

        def 执行(self):
            pass

    管理器2 = 任务依赖管理器([任务E, 任务F])
    循环依赖2 = 管理器2.检查循环依赖()
    print(f"  发现循环依赖: {循环依赖2}")

    try:
        管理器2.拓扑排序()
    except 循环依赖异常 as e:
        print(f"  拓扑排序失败: {e}")
